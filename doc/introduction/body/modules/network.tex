% !TeX root = ../../introduction.tex
\ifx\maindoc\undefined
\errmessage{This file must be input from a main document!}
\fi

\section{网络模块设计说明}
本项目采用 Netty 框架处理底层网络通信，实现了一套基于 Socket 的客户端-服务器架构，它作为VCampus系统客户端与服务器端之间通信的基石，其设计的可靠性、高效性与安全性直接决定了整个系统的运行质量。通信数据使用 JSON 格式进行序列化与反序列化，通过自定义的编解码器处理请求与响应报文，旨在构建一个稳定、可扩展的通信框架，以满足虚拟校园多用户实时交互的业务需求。

\subsection{Socket}
Socket是网络模块中最基础的通信端点，Java原生Socket API为建立TCP连接提供了直接支持。在本暑期实训项目之中计划设计的V-Campus系统中，Socket的创建与管理策略在客户端和服务器端有着明确的区分。
\subsubsection{客户端实现}
本项目计划将客户端通过封装好的 Socket 客户端类建立与服务器的长连接，支持发送请求并异步接收响应，内部自动处理连接重试和异常断开。

在客户端，Socket的创建发生在其需要与服务器进行交互时。通常，会在应用程序初始化阶段或用户登录时，通过new Socket尝试与指定的服务器地址和端口建立连接。该连接一旦成功建立，便会被缓存并复用于该客户端会话期间后续的所有网络通信，直至用户登出或应用程序关闭时才显式关闭，以避免频繁建立和断开连接所带来的性能损耗。客户端需要负责监控此连接的状态，并在连接意外中断时触发重连机制，以保证服务的连续性。
\subsubsection{服务端\textbf{NettyServer}实现}
服务器端主要基于Netty-NIO框架构建，负责监听指定端口、接收客户端连接、处理网络I/O事件并分发业务请求。其核心设计与功能如下：
\begin{enumerate}
    \item 采用主从Reactor线程模型，bossGroup线程组负责接受新连接，workerGroup线程组负责处理已建立连接的I/O操作，有效提升并发处理能力。
    \item 通过ServerBootstrap类进行启动配置，初始化通道管道（Pipeline），指定编解码器及业务处理器。
    \item 提供run(router, database)方法，接收全局路由管理器（Router）及数据库会话等依赖项后启动服务。
\end{enumerate}

\subsection{输入输出流}
在本系统中，所有网络通信均基于Netty框架实现，通过自定义的编解码器处理请求与响应数据的序列化与反序化。输入输出流的处理是网络通信层的核心部分，确保数据能够正确、高效地在客户端与服务器之间传输。
\subsubsection{读取输入}
Netty通过ChannelPipeline机制对输入流进行处理。服务器启动时，我们在Pipeline中配置了自定义的处理器，主要包括：
\begin{enumerate}
    \item \textbf{JsonObjectDecoder：}用于将接收到的字节流按JSON格式进行解码，解析为可操作的Java对象
    \item \textbf{NettyHandler：}继承自ChannelInboundHandlerAdapter，负责处理解码后的请求对象。在其channelRead方法中，我们对请求进行路由匹配、权限校验，并调用相应的业务逻辑处理单元。
\end{enumerate}
以下为主要处理流程的处理代码：
\begin{lstlisting}
EventLoopGroup bossGroup = new NioEventLoopGroup();
EventLoopGroup workerGroup = new NioEventLoopGroup();
try {
    ServerBootstrap b = new ServerBootstrap();
    b.group(bossGroup, workerGroup)
        .channel(NioServerSocketChannel.class)
        .childHandler(new ChannelInitializer<SocketChannel>() {
            @Override
            public void initChannel(@NonNull SocketChannel ch) {
                ch.pipeline().addLast(new JsonObjectDecoder())
                            .addLast(new NettyHandler(router));
            }
        })
        .option(ChannelOption.SO_BACKLOG, 128)
        .childOption(ChannelOption.SO_KEEPALIVE, true);
    ChannelFuture f = b.bind(port).sync();
    f.channel().closeFuture().sync();
} finally {
    workerGroup.shutdownGracefully();
    bossGroup.shutdownGracefully();
}
\end{lstlisting}
在NettyHandler的channelRead方法中，我们对请求对象进行进一步处理，包括路由查找、会话管理和权限判断，最终将请求分发给相应的Controller进行处理，并生成响应结果。

\subsubsection{发送输出}
处理完成后，服务器通过ChannelHandlerContext将响应对象写回客户端。我们使用Gson将Response对象序列化为JSON字符串，再通过Netty的Channel写入通道，最终发送至客户端。关键发送代码如下：
\begin{lstlisting}
    private void sendResponse(ChannelHandlerContext ctx, Response response) {
    ctx.writeAndFlush(Unpooled.copiedBuffer(gson.toJson(response), CharsetUtil.UTF_8));
}
\end{lstlisting}
该过程可确保响应数据以UTF-8编码的JSON格式通过网络传回客户端，从而最终完成一次完整的请求-响应交互。
