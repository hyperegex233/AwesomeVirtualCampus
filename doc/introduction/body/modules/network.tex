% !TeX root = ../../introduction.tex
\ifx\maindoc\undefined
\errmessage{This file must be input from a main document!}
\fi

\section{网络模块设计说明}
网络模块主要采用Socket编程实现客户端与服务器之间的TCP长连接通信，它作为VCampus系统客户端与服务器端之间通信的基石，其设计的可靠性、高效性与安全性直接决定了整个系统的运行质量。本系统计划采用基于TCP协议的Socket通信作为远程交互的主要手段，通过自定义的应用层协议（以可序列化的Message对象为载体）在两端之间传输指令与数据。该模块的设计充分考虑了并发处理、连接管理、异常恢复与资源释放等关键问题，旨在构建一个稳定、可扩展的通信框架，以满足虚拟校园多用户实时交互的业务需求。
\subsection{Socket}
Socket是网络模块中最基础的通信端点，Java原生Socket API为建立TCP连接提供了直接支持。在本暑期实训项目之中计划设计的V-Campus系统中，Socket的创建与管理策略在客户端和服务器端有着明确的区分。
\subsubsection{客户端}
在客户端，Socket的创建发生在其需要与服务器进行交互时。通常，会在应用程序初始化阶段或用户登录时，通过new Socket(SERVER_IP, SERVER_PORT)尝试与指定的服务器地址和端口建立连接。该连接一旦成功建立，便会被缓存并复用于该客户端会话期间后续的所有网络通信，直至用户登出或应用程序关闭时才显式关闭，以避免频繁建立和断开连接所带来的性能损耗。客户端需要负责监控此连接的状态，并在连接意外中断时触发重连机制，以保证服务的连续性。连接服务器Socket的代码片段具体如下所示：

\subsubsection{客户端}
客户端通信服务接口IMessageClientSrv定义了客户端所有网络操作的核心契约，它将网络通信的细节对上层业务逻辑隐藏起来，提供了一个简洁、抽象的异步消息收发模型。该接口的核心方法send(Message msg)负责将封装好的业务请求消息发送至服务器端，其内部实现会首先调用validate(Message msg)方法对待发送消息的基本有效性进行校验，例如检查目标地址是否为空、必要的载荷数据是否存在等，以防止无效请求占用网络资源。

发送过程通常采用异步非阻塞模式，以避免阻塞用户界面主线程，确保客户端操作的流畅性。与之对应的是消息的接收机制，尽管在严格的接口定义中可能不直接暴露给业务层，但底层通信线程会持续监听来自服务器端的响应，并通过回调机制或事件驱动模型（如观察者模式）将收到的Message对象传递给相应的业务处理器进行处理。

整个通信生命周期内的连接建立、重试逻辑、超时控制以及安全认证（如SSL/TLS握手）都封装在该接口的实现类之中，使得业务开发人员能够专注于功能实现，而无需关心底层的网络复杂性。
\subsubsection{服务器端 \texttt{NettyServer}}
服务器端通信服务接口IMessageServerSrv则承担着更为艰巨的任务，它需要管理所有客户端的连接请求、并发处理海量的并发消息并将其路由至正确的业务逻辑单元。其start()方法是服务器启动的入口，负责初始化服务器Socket、创建线程池以及启动监听线程，从而进入等待客户端连接的状态。与之相对的stop()或shutdown()方法则用于优雅地关闭服务，它会拒绝新的连接请求，同时等待所有已连接的客户端处理完毕当前任务后再释放资源，确保数据的一致性。

与客户端类似，它也提供了send(Message msg, Socket clientSocket)方法用于向特定客户端发送响应消息，以及broadcast(Message msg)方法用于向所有在线客户端进行广播推送，这在通知类场景中尤为有用。服务器端的receive操作并非一个主动调用的方法，而是由每个客户端连接专属的处理线程循环执行的，它们不断地从Socket输入流中读取Message对象。随后，服务器会根据消息头中的类型（type）和状态码（statusCode），利用责任链模式或命令模式将其分派给预先注册的、专门处理该类消息的MessageHandler进行处理，从而实现请求的精确路由与业务的解耦。
\subsection{输入输出流}
\subsubsection{读取输入}
\subsubsection{发送输出}
