\documentclass[a4paper]{ctexart}

\usepackage[left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm]{geometry}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{booktabs} % For professional looking tables
\usepackage{listings} % For code snippets
\usepackage{xcolor}   % For code snippet styling
\usepackage{hyperref} % For hyperlinks in the document
\usepackage{comment}
% --- Configure Listings for Code Snippets ---
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.95}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{green!50!black},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Java
}
\lstset{style=mystyle}

% --- Title Information ---
\title{\bfseries 虚拟校园系统软件设计说明书}
\author{撰稿人：沈傲东}
\date{
    版本号：V1.0 \\
    \vspace{0.5em}
    日\quad 期：2023-8-18
}

% --- Document Start ---
\begin{document}

\maketitle
\begin{center}
    \vspace{1.5cm}
    \Large \bfseries 东南大学计算机科学与工程学院
    \vspace{2cm}
\end{center}

\begin{abstract}
    \noindent 本文档为虚拟校园系统的软件设计说明书，旨在详细阐述系统的整体架构、模块划分、接口设计以及关键技术实现，为后续的编码、测试和维护工作提供清晰的指导。
\end{abstract}

\newpage

% --- Modification History ---
\section*{修订历史}
\begin{tabular}{p{0.2\textwidth} p{0.2\textwidth} p{0.2\textwidth} p{0.3\textwidth}}
    \toprule
    \textbf{修改日期} & \textbf{版本号} & \textbf{修改人} & \textbf{修改描述} \\
    \midrule
                  &              &              &               \\
                  &              &              &               \\
                  &              &              &               \\
    \bottomrule
\end{tabular}

\newpage

% --- Table of Contents ---
\tableofcontents
\newpage

% --- Main Content ---

\section{引言}

\subsection{编写目的}
本文档旨在详细阐述“虚拟校园 (VCampus)”项目的整体设计方案，明确其系统架构、模块划分与核心技术细节。

该系统旨在构建一个多功能的虚拟校园平台，核心功能模块包括：用户管理（含注册、登录与授权）、学生学籍管理、在线选课系统、数字图书馆、校园商店、线上银行以及一个集成的LLM智能聊天界面。

为确保系统的高效、稳定与可扩展性，本次设计遵循了一系列现代软件工程原则。系统整体采用客户端/服务器（C/S）架构，并通过Socket通信实现数据交互 。在业务实现上，我们遵循严格的分层设计（Layered Architecture）与模型-视图-控制器（MVC）模式 ，以实现业务逻辑与用户界面的有效分离。此外，项目还将采用分布式开发思想，通过多线程处理并发用户请求 ，为项目构建一个结构清晰、易于协作和维护的开发基础。

本文档是指导项目开发全过程的文件。开发团队严格遵循本文档所定义的架构、接口与规范进行编码、测试与集成工作，以确保精确实现上述各模块功能的过程中高效协作。并且本文档为学生、老师、管理员等用户提供针对该项目详实的使用说明。

\subsection{背景}
软件系统名称: 虚拟校园 (VCampus) 系统 。
项目任务来源: 本项目是“暑期学校专业技能实训课程”设定的课程设计任务 ，旨在通过构建一个功能完善的软件系统，锻炼和检验开发团队在需求分析、架构设计、团队协作及项目管理方面的综合能力。
开发者: 姓名
目标用户: 本系统的主要用户群体为虚拟校园环境中的在校学生、教职员工以及负责后台维护的系统管理员。
运行环境: 系统基于客户端/服务器 (C/S) 架构 ，服务器端程序需部署在安装了兼容 JDK 17 版本 Java 运行环境的服务器上 ，并连接至 MySQL 数据库 。客户端程序为桌面应用程序，可在主流个人计算机操作系统（如 Windows, macOS, Linux）上跨平台运行。

\subsection{定义}
\begin{itemize}
    \item \textbf{系统}: 指本文档所描述的虚拟校园系统软件。
    \item \textbf{用户}: 包括学生、教师和系统管理员。
\end{itemize}

\subsection{参考资料}
\subsubsection{项目内部文件}

《暑期学校专业技能实训课程安排》：本文档是项目的任务来源规定了项目的总体要求、功能模块、技术栈约束及考核标准。

《软件设计说明书DEMO》：为本次设计说明书的编写提供了内容结构和格式参考。

\subsubsection{国家及行业标准}

GB/T 8567-2006 计算机软件文档编制规范：本设计说明书的结构和内容参考了该国家标准，以确保文档的规范性。

Google Java Style Guide: 作为项目编码规范的主要参考，用于统一团队的代码风格、命名约定和格式化标准，以提升代码的可读性和可维护性。

Oracle Code Conventions for the Java(TM) Programming Language: 官方Java编程语言代码约定，作为编码规范的补充参考。

\subsubsection{技术与架构设计文献}

《Effective Java》 (3rd Edition) by Joshua Bloch: Java 语言的权威实践指南，为编写出更清晰、健壮、可复用的高质量Java代码提供了宝贵的建议。

《设计模式：可复用面向对象软件的基础》 (Design Patterns: Elements of Reusable Object-Oriented Software): 经典的 GoF 设计模式参考手册，为项目中如 MVC、单例等模式的应用提供了理论指导。

《代码整洁之道》 (Clean Code: A Handbook of Agile Software Craftsmanship): 软件工程领域的经典著作，指导开发者编写易于理解、易于维护的代码，其思想贯穿于本项目的编码实践中。

《架构整洁之道》 (Clean Architecture: A Craftsman's Guide to Software Structure and Design): 深入阐述了软件架构设计的核心原则，如组件、层次、边界和依赖关系等，是本项目进行分层设计和模块解耦的重要理论指导。

\section{程序系统的分析}

\subsection{可行性分析}

本节旨在对“虚拟校园 (VCampus)”项目的可行性进行综合评估，从技术实现、经济效益和实际操作三个维度，判断项目是否具备开发条件。

从技术可行性角度看，本项目是完全可实现的。项目要求采用客户端/服务器（C/S）架构，并通过Java Socket及多线程技术进行开发，这些都是成熟且拥有丰富文档支持的主流技术 。开发环境（Eclipse、兼容JDK 1.7的Java版本）和数据库（Access/MySQL）均为标准、易于获取的工具，不存在技术壁垒 。虽然团队成员主要以C++为开发语言，但具备扎实的计算机科学基础，将现有编程知识迁移至Java语言，并掌握Swing、Socket等API不存在根本性困难。因此，在技术层面，本项目风险可控。

在经济可行性方面，我们需将常规的“投资回报率”调整为“投入产出比”来评估。本项目的主要“投入”是开发团队在课程期间投入的时间和精力，而非大量的资金。所需的开发软件均为开源或免费版本，硬件则基于团队成员的个人计算机，几乎无直接的财务成本。而项目的“产出”则具有极高的价值：它不仅是完成“暑期学校专业技能实训课程”的必要条件 ，更是一次宝贵的、完整的软件工程实践。通过本项目，团队成员将获得在分层架构设计、网络通信、数据库交互以及团队协作方面的综合实战经验 ，这对未来的职业发展是重要的无形资产。因此，本项目具备显著的经济可行性。

最后，就操作可行性而言，VCampus系统旨在将校园中分散的线下业务（如学籍管理、选课、图书馆借阅等）整合到统一的线上平台，这符合教育信息化的大趋势 。对于目标用户（学生、教师、管理员），该系统能显著简化办事流程，提高信息获取效率 。系统所模拟的业务流程均源于真实的校园场景，易于用户理解和接受 。只要用户界面设计得足够直观易用，系统在理论上的校园环境中推广和使用，不存在明显的操作障碍。

综上所述，VCampus项目在技术、经济和操作层面均被证明是可行的。项目团队具备完成开发所需的技术学习和实践能力，项目成果能带来远超投入的知识回报，且其产品定位符合实际应用场景的需求。因此，项目具有可行性。

\subsection{需求分析}

本章节将详细定义VCampus系统的功能性需求与非功能性需求，作为后续系统设计、开发、测试及验收的基准。

\subsubsection{功能需求}

功能需求详细描述了系统应为用户提供的各项服务和功能。

1.用户管理模块（此模块是系统的基础，为所有用户提供身份认证与管理服务）
注册: 新用户（学生或管理员）能够通过界面输入必要信息（如用户名、密码、角色）创建新账户 。
登录/登出: 已注册用户可以通过唯一的用户名和密码登录系统，访问其权限对应的功能 。用户也可以随时安全退出登录状态 。
授权: 系统需根据用户角色（学生、管理员）区分权限，确保不同角色只能访问其被授权的功能模块 。
2. 学生学籍管理模块（该模块主要面向管理员，用于管理学生的基本信息）
信息录入与修改: 管理员可以添加、删除和修改学生的学籍信息。
信息查询: 支持通过学号、姓名等关键信息快速查询学生资料。
列表视图：通过列表查看所有学生的信息。
3. 选课系统模块（此模块为学生提供在线选课服务，是系统的核心业务功能之一）
课程信息浏览: 学生可以查看当前学期所有可选课程的列表，包括课程名称、授课教师、学分、学时等信息。
在线选课/退课: 在规定时间内，学生可以根据个人培养计划选择或退选课程。
个人课表查询: 学生可以查看自己已选课程的时间和地点安排。
4. 图书馆模块（模拟校园图书馆的核心功能）
图书查询: 用户可以根据书名、作者等信息检索馆藏图书。
借阅/归还: 模拟图书的借阅和归还流程。
图书信息浏览：可以通过列表视图浏览图书信息。
5. 校园商店与银行模块（提供虚拟的校园生活服务）
商店: 用户可以浏览商品并使用虚拟货币进行购买。
银行: 提供虚拟货币的存取款、转账等基本银行服务。
6. LLM聊天界面模块（集成一个基于大语言模型的智能问答界面，为用户提供校园信息咨询等服务）

\subsubsection{非功能需求}

非功能需求定义了系统的质量属性和在运行环境中必须遵守的约束。

性能需求: 系统应具备良好的响应能力。在高并发场景下（例如选课高峰期），服务器端需能通过多线程机制有效处理多个客户端的同时请求，确保系统不出现严重延迟或无响应。

兼容性需求: 系统开发必须严格遵守技术栈约束。后端逻辑需使用Java语言编写，JDK版本必须兼容1.7 。数据库可选用Access或MySQL，但需保证SQL语句的通用性 。

可靠性与健壮性: 客户端与服务器端的Socket通信必须建立完善的异常处理机制，能够处理网络中断、超时等常见问题，避免程序因网络波动而崩溃 。

安全性需求: 用户密码等敏感信息在数据库中存储时不应为明文。客户端与服务器之间传输的所有对象都必须实现可序列化接口，并保持版本一致性，以防止数据传输错误 。

代码规范与可维护性: 项目代码必须遵循统一的编码规范（如Google Java Style Guide），并为主要的类和方法提供标准的JavaDoc注释 。系统的设计应严格遵循分层原则，确保各层之间职责清晰、耦合度低，便于后续的功能扩展与维护 。

\subsection{开发设计环境}

\subsubsection{IntelliJ IDEA}

本项目计划采用IntelliJ IDEA作为核心集成开发环境（IDE）。该工具由JetBrains开发，广泛应用于Java项目，其突出优势体现在智能代码补全、动态错误检测、强大的重构功能以及内建的版本控制系统集成，在java编程方面具有较大的优势。尽管实训课程安排中提及了Eclipse ，但经过团队的权衡与考量，IntelliJ IDEA被认为是更优的选择。虽然Eclipse在处理多项目工作区和增量编译方面具有一定优势，但其插件生态相对不活跃，且在Java代码的实际编辑体验、重构辅助和智能代码生成方面，Intelli-J IDEA具有明显领先优势 。对于一个时间有限的暑期实训项目，快速、高效地编写业务逻辑代码至关重要。IntelliJ IDEA所提供的卓越编辑辅助功能能够显著加速开发流程，其与Maven的深度集成也确保了项目构建过程的稳定性和可重复性。

IntelliJ IDEA在此项目之中所体现的核心优势体现在以下几个方面：

1.智能编码辅助与动态分析： IntelliJ IDEA提供强大的智能代码补全、动态错误检测和即时代码质量分析功能。这些功能能够实时识别潜在的代码缺陷和不规范之处，并提供优化建议。这不仅加快了编码速度，也从源头保障了代码的健壮性和可维护性 。
2.强大的重构功能： 对于多人协作的“V-campus”项目而言，代码结构会随着开发进程不断演进。IntelliJ IDEA提供的强大、安全的自动化重构功能（如类更名、方法提取等），能够确保在修改项目结构时，关联引用能够被正确更新，从而有效维护了代码库的完整性 。
3.深度集成版本控制系统： 该IDE内置了对Git、Subversion等主流版本控制系统的深度支持。开发人员无需离开IDE环境即可完成代码提交、分支管理、冲突解决等版本控制操作，极大地简化了团队协作流程 。

此外，IntelliJ IDEA也对Maven和Gradle等构建工具提供了深度支持，能够有效管理项目依赖与构建流程，显著提升开发效率与代码可维护性。

\subsubsection{JDK 17}

本项目的核心开发语言环境选用Java Development Kit (JDK) 17。该版本由Oracle指定为长期支持（LTS）版本，这代表着它将获得长达数年的稳定安全、性能和错误修复更新。JDK 17在语言特性、运行性能及安全性方面具备多项改进，如引入了Sealed Classes、Pattern Matching for Switch等新语法特性，增强了类型系统的表达力与代码的简洁性。其优化的垃圾回收机制和提升的编译效率也为系统的高并发处理与稳定运行提供了坚实基础。同时该版本兼容性较强，也更加稳定。

选择LTS版本有助于为“虚拟校园”系统的长期稳定运行提供坚实保障，避免了因使用非LTS版本而可能面临的频繁版本升级和兼容性风险。 JDK 17在语言特性和平台性能方面也进行了多项重要改进。其中，对于本项目开发尤为有价值的特性包括：

1.密封类（Sealed Classes）： 该特性允许开发者明确地声明一个类或接口可以被哪些特定的子类继承或实现。这增强了类型系统的表达能力，为系统中的实体类（如User及其子类Student、Teacher、Admin）提供了更严谨的设计约束，从而提升了代码的安全性和可维护性 。
2.switch表达式的模式匹配（Pattern Matching for switch）： 这一预览特性简化了处理不同数据类型或状态的逻辑分支。通过将instanceof表达式和switch语句相结合，它能够显著减少代码冗余，提高代码的可读性与简洁性 。在处理“虚拟校园”系统中不同类型的消息（Message）或用户请求时，这一特性可以极大地简化业务逻辑层的开发 。

\subsubsection{MySQL 8.4.6 LTS}

数据库管理系统方面本软件设计采用MySQL 8.4.6 LTS版本。该版本不仅完全支持ACID事务，还提供诸如窗口函数、通用表表达式（CTE）和JSON字段增强功能等高级特性，极大丰富了数据操作与查询的能力。

此外，MySQL 8.4.6在身份验证、数据加密与权限管理等方面引入多项安全机制，保障了数据的机密性与完整性，非常适用于对数据一致性要求较高的校园管理系统。此版本不仅完全支持ACID事务，确保了在处理选课、学生学籍变更等核心业务中数据的一致性与完整性，还提供了注入公共表达式以及窗口函数等高级特性，极大丰富了数据操作能力。

\subsubsection{Java FX}

图形用户界面（GUI）部分基于Java FX框架实现。作为一个现代、跨平台的UI框架，Java FX提供了丰富的可视化组件、灵活的布局控制（FXML）以及CSS样式定制能力，能够构建响应迅速、视觉效果良好的桌面应用程序。其与JDK的紧密集成简化了部署过程，同时具备与底层图形硬件的良好协同，显著提升了客户端的用户体验。
其核心优势首先体现在现代化与跨平台，这代表了JavaFX提供了丰富的可视化组件和灵活的布局控制，能够构建响应迅速、视觉效果良好的桌面应用程序 。其跨平台特性确保了客户端系统在不同操作系统上（如Windows, macOS, Linux）表现出一致的用户体验。

其次体现在了设计与逻辑分离，JavaFX支持使用FXML（一种基于XML的声明式UI语言）来定义界面布局，并使用CSS样式表来定制界面风格 。这种模式将界面设计与后端业务逻辑进行了清晰的分离，完全契合了项目中强调的“分层设计”原则（MVC） 。它允许团队中的UI设计师与后端开发人员独立工作，从而显著提升开发效率。

\subsubsection{Maven}

本项目还计划采用Apache Maven作为项目构建与依赖管理工具。Maven是一款基于项目对象模型（POM）的软件项目管理工具，可自动化完成项目的编译、测试、打包及部署等生命周期管理任务。通过规范的目录结构和统一的依赖管理机制，Maven显著提升了项目的可维护性与团队协作效率。

其强大的插件生态系统和与主流IDE（如IntelliJ IDEA）的无缝集成，进一步确保了构建过程的可重复性和环境一致性，为大型多模块项目的依赖控制与构建流程提供了稳定基础。

\section{程序系统的结构}
本系统采用经典的三层架构（C/S 架构的变体），即表示层、业务逻辑层和数据访问层。
\begin{itemize}
    \item \textbf{表示层 (UI)}: 负责用户界面的展示和交互，采用Java Swing构建。
    \item \textbf{业务逻辑层 (BLL)}: 处理系统的核心业务逻辑，如用户认证、消息转发等。
    \item \textbf{数据访问层 (DAL)}: 负责与数据库进行交互，实现数据的持久化存储（CRUD操作）。
\end{itemize}

\section{用户管理模块设计说明}
\subsection{模块背景}
用户管理是系统的基础模块，负责用户的注册、登录、信息管理等功能，是保障系统安全和正常运行的前提。

\subsection{需求分析}
\begin{itemize}
    \item 用户能够注册新账号。
    \item 用户能够使用账号密码登录系统。
    \item 用户能够查看和修改个人信息。
    \item 管理员能够管理所有用户信息。
\end{itemize}

\subsection{系统设计}
\subsubsection{界面设计}
设计简洁明了的登录、注册和用户信息界面。
\subsubsection{模块流程图}
(此处原文档为图像，暂不包含)
\subsubsection{类分析}
\begin{itemize}
    \item \textbf{User}: 用户实体类，封装用户属性。
    \item \textbf{UserDao}: 数据访问对象，负责User类的数据库操作。
    \item \textbf{UserService}: 业务逻辑类，处理用户管理的业务逻辑。
    \item \textbf{LoginFrame}, \textbf{RegisterFrame}: Swing界面类。
\end{itemize}

\section{Xxx模块设计说明}
 (内容略)

\section{公共模块设计说明}
\subsection{模块概述}
公共模块（Common Module），作为“V-Campus”系统整体架构的基石，其战略定位在于承载客户端与服务器端之间所有共享的核心组件、数据模型、抽象接口和工具类，其设计质量直接决定了系统的可维护性、可扩展性以及客户端与服务器端协作的一致性。在项目所遵循的经典分层架构（view、biz/srv、vo、dao）中，此模块主要扮演了vo（值对象）层的角色，并集成了跨层、跨应用的通用服务与辅助功能。其核心价值在于通过单一代码源实现模型与接口的同步，从而规避了分布式开发中常见的类定义不一致问题，确保了数据模型在网络传输中的完整性与互操作性。

这种中心化的设计不仅极大地提升了代码复用率，也为后续的团队协作、功能扩展和系统维护奠定了坚实的基础，体现了项目团队在架构设计层面的深思熟虑 。本系统严格遵循面向接口编程与关注点分离的原则，将那些在系统多处复用、尤其是需要在网络两端共享的核心数据结构、工具方法及基础服务抽象为独立的公共模块。这些模块被组织在独立的Java项目中，并通过Maven依赖管理机制为客户端和服务器端项目所引用，确保了二进制级别的一致性，彻底避免了因类定义版本差异而引发的序列化异常等潜在问题。所有在此模块中定义的、需要在网络中进行传输的对象，均严格实现了java.io.Serializable接口，这是保障基于Java对象流的Socket通信能够正常工作的先决条件。
\subsection{Message类}
Message类，用于在客户端和服务器之间传递信息。它封装了消息类型、发送者、接收者、内容等核心数据，是整个C/S架构中通信协议的核心载体与抽象，它被设计为一个高度通用且可扩展的消息信封，旨在封装所有类型的客户端与服务器间的交互信息。

其重要性在于它统一了系统中诸如登录请求、课程数据查询、借阅指令等所有异构消息的传输格式，使得网络通信层能够以一致的方式处理各种业务请求与响应。该类的设计包含了多个关键字段,这里选取一些较为关键的进行展示如下所示：

uid作为全局唯一标识符（GUID），用于唯一标识每一条消息，这对于请求-响应的匹配、消息去重与异步通信下的日志追踪至关重要；

name字段定义了消息的可读名称，便于调试与日志记录；

type是一个枚举类型（例如MessageType.COMMAND, MessageType.DATA, MessageType.AUTH等），用于在接收端进行初步的消息路由，决定由哪个业务处理器（Handler）来接手后续处理；

而statusCode字段承载了操作结果的状态信息，借鉴HTTP状态码的理念（如200表示成功，404表示资源未找到，500表示服务器内部错误），使得客户端能标准化地解析处理结果；

data是一个声明为Object类型的成员，它承载了消息的实际业务载荷，其具体类型可由业务逻辑决定（如一个User对象、一个Course列表或一个简单的字符串），但其必须实现Serializable接口；

最后的sender字段记录了消息的发起方标识，通常为用户名或用户ID，用于服务端的身份验证与审计日志。通过对这些字段的组合与填充，Message类能够灵活适应从用户认证到数据同步等各类应用场景。各个关键字段所包含的特征可由下表直观展示:

\begin{tabular}{llll}
    \toprule
    \textbf{序号} & \textbf{名称} & \textbf{类型}    & \textbf{约束}            & \textbf{备注} \\
    \midrule
    1           & uid           & Long           & 唯一性        &标识符\\
    2           & name          & String         & 6-16个字符    &名称  \\
    3           & type          & Enumberation   & 命令、数据     &类型 \\
    4           & statuscode    & String         &               &状态码           \\
    5           & data          & Object         & 可序列化       &传输数据   \\
    6           & sender        & Object/String  &               &发送者/用户名\\
    ...         & ...           & ...            &...            &...\\
    \bottomrule
\end{tabular}


\subsection{User}
User类即为用户实体类，它包含了用户的ID、用户名、密码、昵称等属性，是系统核心业务实体的基础抽象，同时建模了虚拟校园环境中所有参与者的基本属性和行为。作为一个将在网络中传输并在持久化层存储的实体，它同样实现了Serializable接口。该类不仅包含了最基本的身份认证信息（如唯一标识用户的id和经过哈希加密处理的密码pwd），还包含了描述性属性如age。

尤为关键的是，它通过一个role字段（通常为枚举类型，如UserRole.STUDENT, UserRole.TEACHER, UserRole.ADMIN）来实现基于角色的访问控制（RBAC），该系统权限体系的基石。在后续的设计中，考虑到不同角色用户可能存在行为与属性的差异，可以采用继承机制对User类进行拓展，派生出Student、Teacher和Administrator等子类，从而通过多态特性更精确地建模现实世界。此外，该类应遵循JavaBean规范，提供所有属性的getter和setter方法，并重写toString(), equals()和hashCode()方法，以确保其能够方便地在各种业务逻辑、数据展示及集合操作中被正确处理。

其所包含的一些关键字段如下表直观可视：
\begin{tabular}{llll}
    \toprule
    \textbf{序号} & \textbf{名称} & \textbf{类型}    & \textbf{约束}            & \textbf{备注} \\
    \midrule
    1           & id           & String          &               &登录名\\
    2           & pwd          & String         & 6-16个字符    &密码  \\
    3           & age          & Integer        & 非0           &年龄 \\
    ...         & ...           & ...            &...            &...\\
    \bottomrule
\end{tabular}
\subsection{数据库工具类DbHelper}
DbHelper类是一个专注于封装底层数据库连接与操作细节的基础设施类。其首要职责是管理数据库连接的生命周期，这是通过实现一个线程安全的数据库连接池来达成的，该池化机制能有效避免频繁创建和关闭连接所带来的巨大性能开销，从而提升系统在高并发场景下的吞吐能力。

该类通常被设计为单例模式，以保证整个应用程序内资源管理的统一性，它对外提供了一系列静态方法，如getConnection()用于从连接池中获取一个可用连接；executeQuery(String sql, Object... params)用于执行带参数的SQL查询语句，并返回ResultSet；executeUpdate(String sql, Object... params)用于执行插入、更新、删除等操作，返回受影响的行数；最后releaseConnection(Connection conn)并非真正关闭连接，而是将其返还给连接池以供复用。

此外，该类还承担了处理SQL异常、事务管理（如开启、提交、回滚事务）的职责，并将底层的SQLException转换为更易于上层业务逻辑处理的统一异常类型，从而将业务代码从繁琐的JDBC样板代码和资源管理中彻底解放出来。
\subsection{数据存取类DAO}
数据存取对象（DAO）模式，即Data Access Object模式，是公共模块中实现数据持久化逻辑的核心设计模式，它为每个实体类提供一个DAO接口及其实现，在业务逻辑与数据库操作之间建立了一个清晰的抽象层。每一个DAO接口及其实现类（如UserDAO, CourseDAO）专门负责对某一个特定实体对象进行CRUD（创建、读取、更新、删除）操作以及其他相关的数据查询。这种集中化的数据访问方式带来了多重好处：

首先，它将数据访问逻辑限制在这一层，避免了SQL语句 scattered throughout the business code，极大地提高了代码的可维护性和可读性；其次，它使得数据源的变化（例如从MySQL迁移到PostgreSQL）对上层业务逻辑是透明的，业务层仅依赖于DAO接口，而不关心其具体实现，这符合“针对接口编程，而非实现”的原则；最后，它简化了单元测试，因为可以很容易地为DAO接口创建Mock实现，从而对业务逻辑进行隔离测试。一个典型的UserDAO接口会定义诸如findUserById(String id), insertUser(User user), updateUser(User user), deleteUserById(String id)等方法，而其具体的JdbcUserDAO实现则会利用前述的DbHelper来执行具体的SQL命令，并负责将ResultSet中的数据行映射为User对象（即ORMapping的过程）。
\subsection{工具类}
工具类提供一些静态方法，用于处理如日期格式化、字符串校验等通用功能。同时也集合了系统中广泛使用的、与特定业务无关的通用辅助方法。这些类通常被设计为最终类（final class）并包含私有构造方法，以防止被实例化或继承，其所有方法均为静态方法。

常见的工具类包括：StringUtils，提供字符串的非空判断、 trimming、格式化等操作；DateUtils，处理日期与字符串之间的转换、日期计算等；SecurityUtils，负责密码的加盐哈希（如使用BCrypt算法）、生成令牌等安全相关操作；LogUtils，提供统一的日志记录接口，包装了如Log4j或SLF4J等日志框架，确保整个系统日志输出格式和行为的一致性；JsonUtils，基于诸如Jackson或Gson库，提供Java对象与JSON字符串之间序列化与反序列化的能力，这对于未来可能扩展的RESTful接口或日志存储尤为重要。这些工具类的存在避免了通用代码的重复，保证了常用操作实现的一致性，是提升代码质量与开发效率的关键。
\subsection{其他类…}
除了上述所提到的项目的公共设计模块之中所计划涉及到的一些核心类，公共模块中还可能包含一系列支撑系统运行的其他重要类。下面就举出一些经典例子：Constants类集中定义了整个系统中使用的全局常量，如数据库连接字符串、服务器IP地址与端口号、各种状态码、文件路径等，这有利于维护和避免魔法数字的出现。AppException是一个自定义的、系统级的运行时异常基类，所有其他业务异常均可继承自此异常，这使得我们可以通过统一的异常处理机制（如AOP）来捕获和处理异常，并向用户返回友好的错误信息。ConfigLoader类专门负责从外部配置文件（如.properties或.xml文件）中加载配置信息，使系统具备良好的可配置性，无需修改代码即可适应不同的部署环境。这些类与前述模块共同协作，构成了一个健壮、灵活且易于维护的系统基础架构。

\section{网络模块设计说明}
网络模块主要采用Socket编程实现客户端与服务器之间的TCP长连接通信，它作为VCampus系统客户端与服务器端之间通信的基石，其设计的可靠性、高效性与安全性直接决定了整个系统的运行质量。本系统计划采用基于TCP协议的Socket通信作为远程交互的主要手段，通过自定义的应用层协议（以可序列化的Message对象为载体）在两端之间传输指令与数据。该模块的设计充分考虑了并发处理、连接管理、异常恢复与资源释放等关键问题，旨在构建一个稳定、可扩展的通信框架，以满足虚拟校园多用户实时交互的业务需求。
\subsection{客户端 IMessageClientSrv 接口}
客户端通信服务接口IMessageClientSrv定义了客户端所有网络操作的核心契约，它将网络通信的细节对上层业务逻辑隐藏起来，提供了一个简洁、抽象的异步消息收发模型。该接口的核心方法send(Message msg)负责将封装好的业务请求消息发送至服务器端，其内部实现会首先调用validate(Message msg)方法对待发送消息的基本有效性进行校验，例如检查目标地址是否为空、必要的载荷数据是否存在等，以防止无效请求占用网络资源。

发送过程通常采用异步非阻塞模式，以避免阻塞用户界面主线程，确保客户端操作的流畅性。与之对应的是消息的接收机制，尽管在严格的接口定义中可能不直接暴露给业务层，但底层通信线程会持续监听来自服务器端的响应，并通过回调机制或事件驱动模型（如观察者模式）将收到的Message对象传递给相应的业务处理器进行处理。

整个通信生命周期内的连接建立、重试逻辑、超时控制以及安全认证（如SSL/TLS握手）都封装在该接口的实现类之中，使得业务开发人员能够专注于功能实现，而无需关心底层的网络复杂性。
\begin{tabular}{llll}
    \toprule
    \textbf{序号} & \textbf{名称} & \textbf{方法}               & \textbf{备注} \\
    \midrule
    1           & 发送          & Boolean send(Message)     & 发送消息对象到服务器  \\
    2           & 接收          & Boolean receive(Message)  & 从服务器接收消息    \\
    3           & 校验          & Boolean validate(Message) & 校验消息的合法性    \\
    4           & …           & …                         & …           \\
    \bottomrule
\end{tabular}

\subsection{服务器端 IMessageServerSrv 接口}
服务器端通信服务接口IMessageServerSrv则承担着更为艰巨的任务，它需要管理所有客户端的连接请求、并发处理海量的并发消息并将其路由至正确的业务逻辑单元。其start()方法是服务器启动的入口，负责初始化服务器Socket、创建线程池以及启动监听线程，从而进入等待客户端连接的状态。与之相对的stop()或shutdown()方法则用于优雅地关闭服务，它会拒绝新的连接请求，同时等待所有已连接的客户端处理完毕当前任务后再释放资源，确保数据的一致性。

与客户端类似，它也提供了send(Message msg, Socket clientSocket)方法用于向特定客户端发送响应消息，以及broadcast(Message msg)方法用于向所有在线客户端进行广播推送，这在通知类场景中尤为有用。服务器端的receive操作并非一个主动调用的方法，而是由每个客户端连接专属的处理线程循环执行的，它们不断地从Socket输入流中读取Message对象。随后，服务器会根据消息头中的类型（type）和状态码（statusCode），利用责任链模式或命令模式将其分派给预先注册的、专门处理该类消息的MessageHandler进行处理，从而实现请求的精确路由与业务的解耦。
\begin{tabular}{llll}
    \toprule
    \textbf{序号} & \textbf{名称} & \textbf{方法}               & \textbf{备注} \\
    \midrule
    1           & 发送          & Boolean send(Message)     & 发送消息到指定客户端  \\
    2           & 接收          & Boolean receive(Message)  & 从客户端接收消息    \\
    3           & 校验          & Boolean validate(Message) & 校验消息的合法性    \\
    4           & …           & …                         & …           \\
    \bottomrule
\end{tabular}

\subsection{Socket}
Socket是网络模块中最基础的通信端点，Java原生Socket API为建立TCP连接提供了直接支持。在本暑期实训项目之中计划设计的V-Campus系统中，Socket的创建与管理策略在客户端和服务器端有着明确的区分。
\subsubsection{客户端}
在客户端，Socket的创建发生在其需要与服务器进行交互时。通常，会在应用程序初始化阶段或用户登录时，通过new Socket(SERVER_IP, SERVER_PORT)尝试与指定的服务器地址和端口建立连接。该连接一旦成功建立，便会被缓存并复用于该客户端会话期间后续的所有网络通信，直至用户登出或应用程序关闭时才显式关闭，以避免频繁建立和断开连接所带来的性能损耗。客户端需要负责监控此连接的状态，并在连接意外中断时触发重连机制，以保证服务的连续性。连接服务器Socket的代码片段具体如下所示：

\begin{comment}
\begin{lstlisting}
// 连接服务器Socket
clientSocket = new Socket(SERVER_ADDRESS, SERVER_PORT);
\end{lstlisting}
\end{comment}


\subsubsection{服务器端 IServer 接口}
在服务器端，Socket的使用模式则截然不同。当服务器启动时会创建一个ServerSocket实例，并绑定到指定的端口上持续监听连接请求（serverSocket = new ServerSocket(PORT)）。一旦有客户端连接请求抵达，ServerSocket的accept()方法会返回一个新的Socket实例，该实例代表了与这个特定客户端的专用通信通道。服务器端不会在此Socket上直接进行业务处理，而是会立即创建一个新的工作线程（或从线程池中分配一个），并将这个Socket交给该线程负责其整个生命周期的读写操作。

这种“一个客户端一个线程”的模型（可通过线程池优化）是服务器能够同时处理成千上万个客户端连接的关键。服务器端还需要实现一个连接管理器（如ClientThreadMan），用于追踪所有活跃的客户端连接、定时进行心跳检测以判断客户端是否存活、以及在服务器关闭时统一清理所有资源。
\begin{tabular}{llll}
    \toprule
    \textbf{序号} & \textbf{名称} & \textbf{说明} & \textbf{备注}  \\
    \midrule
    1           & IServer     & 服务器管理接口     & 提供启动、关闭和重启服务 \\
    2           & start()     & 启动服务        &              \\
    3           & stop()      & 关闭服务        &              \\
    4           & restart()   & 重启服务        &              \\
    5           & isClosed()  & 检查服务是否关闭    &              \\
    6           & …           & …           & …            \\
    \bottomrule
\end{tabular}
\vspace{1em}

创建服务器Socket的代码片段如下所示：
\begin{comment}
\begin{lstlisting}
// 创建服务器Socket
serverSocket = new ServerSocket(IConstant.SERVER_PORT);
\end{lstlisting}
\end{comment}

\subsection{输入输出流}
建立在Socket连接之上的输入输出流是实现Java对象传输的直接媒介。本项目所设计的VCampus系统计划采用ObjectInputStream和ObjectOutputStream来序列化和反序列化Message对象，从而在网络上传输复杂的对象图。使用 "ObjectInputStream" 和 "ObjectOutputStream" 来序列化和反序列化 "Message" 对象，从而实现在网络中进行传输。

\subsubsection{读取输入}
读取输入数据的过程始于持续监听Socket的输入流。当发送方有数据传来时，接收方会调用ObjectInputStream ois = new ObjectInputStream(socket.getInputStream())来获取对象输入流，随后通过Message msg = (Message) ois.readObject()方法调用阻塞性地读取一个完整的Message对象。这个过程必须是线程安全的，并且通常被放置在一个独立的循环中，以便连续处理来自对端的多个消息。必须注意处理ClassNotFoundException和InvalidClassException等异常，这些异常通常表明客户端与服务器端的类定义（特别是Message及其中data载荷的类）版本不一致，这是分布式系统开发中需要严格管理的问题。

\subsubsection{发送输出}
发送输出数据的过程与读取输入的过程是相对的。首先，发送方要获取Socket的输出流并创建对象输出流：ObjectOutputStream oos = new ObjectOutputStream(socket.getOutputStream())。期中需要注意的是，为了避免潜在的字节顺序标记（BOM）问题，一个Socket连接上的ObjectOutputStream应该只被创建一次并重复使用。

之后，通过oos.writeObject(message)方法将封装好的Message对象序列化并写入输出流。为了确保数据被立即发送出去而不是缓冲在本地，通常在写入操作后需要调用oos.flush()方法。最后，必须妥善处理IOException，例如当网络连接已断开时，写入操作会失败，此时需要触发相应的错误处理逻辑，如尝试重连或通知上层业务逻辑发送失败。

\section{多线程模块设计说明}
\subsection{客户端}
客户端UI操作在事件分发线程（EDT）中执行，避免界面卡顿。网络通信等耗时操作则在单独的工作线程中进行。
\begin{lstlisting}
public static void main(String[] args) {
    SwingUtilities.invokeLater(new Runnable() {
        @Override
        public void run() {
            new MainFrame("title").setVisible(true);
        }
    });
}
\end{lstlisting}

\subsection{服务器端}
服务器采用“请求-响应”模型，主线程负责监听客户端连接请求。一旦有新连接建立，就会创建一个独立的 `ClientThread` 线程来处理该客户端的所有后续请求，从而实现并发处理。

\begin{tabular}{llll}
    \toprule
    \textbf{序号} & \textbf{名称}  & \textbf{说明} & \textbf{备注}     \\
    \midrule
    1           & ClientThread & 客户端线程管理     & 为请求的每个客户端建立一个线程 \\
    \bottomrule
\end{tabular}

\end{document}
